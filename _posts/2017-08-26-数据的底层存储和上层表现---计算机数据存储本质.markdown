---
layout: post
title:  "数据的底层存储和上层表现---计算机数据存储本质"
date:   2017-08-26 15:06:00
categories: essay
---


## 数据底层和上层表现

底层的数据存储都是采用的二进制的形式，无论是任何的文件或者数据，不同的是把底层的数据打印出来的时候会有不同
这里探讨一下数据的底层存储和上层表现的问题
### 例如：
```C
int *ptr = NULL;
int datai = 0x12345678;
long datal = 0xFEDCBA9876543210;
ptr = &datai;
printf("%x\n", *ptr);
ptr = &datal;
printf("%x\n", *ptr);
```
我们采用的系统采用的是64位的Ubuntu，
```
第一行的输出为：12345678
第二行的输出为：FEDCBA98//有些系统可能输出76543210,这里牵涉到大小端的问题。
```
在底层中，int型数据占4个字节,long型数据占用8个字节
我们讨论这一种底层数据的存储方式，大小端问题可以在开一篇文章讨论。

| 内存地址| datai|datal|
| :------| : ------|   : ------| 
|  低地址| 0x1  |0xF|
||0x2||0xE| 
|||0x3| 0xD|
||0x4||0xC|
||0x5||0xB|
||0x6||0xA|
||0x7|0x9|
||0x8|0x8| 
|| |0x7|
| | |0x6|
| | |0x6|
| | |0x5|
| | |0x4|
| | |0x3| 
| | |0x2|
| | |0x1|
|高地址| |0x0|

我们输出的时候，因为ptr是指向int型的，所以输出4个字节内的数据，
在第二行的输出的时候， ptr此时指向datal的首地址，输出这个地址以及之后的相邻四个字节的内容。
在这里ptr指向的是F(十六进制)这个数据的地址。
如果我们按照long的形式输出datai会发生什么呢，结果会有点让人难理解，
```
long *ptrl = &datai;
printf("%lx\n", *ptrl);
```
输出的结果为：
```
12345678××××××××
```
×代表一些随机的数据
按照long的格式输出时，会输出8个字节，所以在最后表现的后面会添加一部分随机数据，将低地址到高地址之间的8位数据全部输出。
在有些系统中会输出
```
××××××××12345678
```
数据在底层存储都是一样的，只是在打印的时候采用了不同的编码方式，或者说是解释方式。有些数据打印出来的和实际存储的有时会有很大的差距。
## C++类成员函数指针的底层与展现
这小节讲述一个底层存储和上层表现无关的例子。
例如：我们将C++的类内函数的地址打印出来的时候，其实是一个偏移量，数值很小。一般认为类成员函数指针是一个偏移量，要和普通函数指针区分开来。

```C++
class Test
{
	public:
		void print()
		{
			std::cout << "hello, world" << std::endl;
		}
};

int main()
{
	void (Test::*func)();
	Test a;
	func = &Test::print;
	std::cout << func << std::endl;
	long *ptr = (long*)&func;
	cout << *ptr << endl;

	return 0;
}
```
在我的系统上输出如下：
```
1
4196864
```
第一行的输出采用的是直接输出func，显示结果为1,这是一个偏移量，是相对与类的首地址来说。偏移一个函数指针之后的内存保存的是func函数。
我们采用了特殊的方法获取到了真实的虚拟地址。
我们所看到的不一定是真实的数据，也许是经过了一定的处理。

